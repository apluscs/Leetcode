class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int N = graph.size();
        vector<int> reps(N, -1);
        for(int i=0; i != N; ++i)
            for(int j = i + 1; j != N; ++j)
                if(graph[i][j] == 1) 
                    set_union(i,j, reps);
        
        unordered_map<int, int> inits;  // each rep --> # initials in its group
        for(int num : initial){
            int p = find(num, reps);  // parent of num
            inits[p]++;
        }
        
        unordered_map<int, int> sizes;  // each 'valid' rep --> # nodes in subgraph
        int most = 0;
        for(int i=0; i!=N; ++i)
            if(reps[i] == -1 && inits[i] == 1){  // i is the rep of its group, only one initial (= "valid")
                
                int count = get_count(reps, i);   
                sizes[i] = count;
                most = max(most, count);
            }
        
        int res = N, backup = N;
        for(int num : initial){ // top is guaranted != 1
            int p = find(num, reps);
            if(sizes.count(p) && sizes[p] == most)
                res = min(res, num);
            backup = min(backup, num);  // value of smallest initial
        }
        
        return res == N ? backup : res;  // if nothing can be done (all initials are with at least one ohter), then return smallest initial
    }
    
    int get_count(vector<int>& reps, int i){
        int res = 0;
        for(int num = 0; num != reps.size(); num++)
            if(find(num, reps) == i) 
                res++;
        return res;
    }
    
    void set_union(int i, int j, vector<int>& reps){    // union find + path compression
        int pi = find(i, reps), pj = find(j, reps);
        if(pi != pj) 
            while(i != -1){   // update every parent of i
                int temp = reps[i];
                reps[i] = pj;
                i = temp;
            }
    }
    
    int find(int i, vector<int>& reps){
        while(reps[i] != -1)
            i = reps[i];
        return i;
    }
};
